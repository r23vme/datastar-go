package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"text/template"

	"github.com/santhosh-tekuri/jsonschema/v6"
)

func toPascalCase(s string) string {
	// Handle special cases first
	specialCases := map[string]string{
		"sseRetryDuration":           "SseRetryDuration",
		"elementsUseViewTransitions": "ElementsUseViewTransitions",
		"patchSignalsOnlyIfMissing":  "PatchSignalsOnlyIfMissing",
		"useViewTransition":          "UseViewTransition",
		"onlyIfMissing":              "OnlyIfMissing",
		"selector":                   "Selector",
		"mode":                       "Mode",
		"elements":                   "Elements",
		"signals":                    "Signals",
		"outer":                      "Outer",
		"inner":                      "Inner",
		"remove":                     "Remove",
		"replace":                    "Replace",
		"prepend":                    "Prepend",
		"append":                     "Append",
		"before":                     "Before",
		"after":                      "After",
	}
	
	if pascal, ok := specialCases[s]; ok {
		return pascal
	}
	
	// For simple words, just capitalize first letter
	if len(s) == 0 {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getDefaultDescription(name string) string {
	descriptions := map[string]string{
		"sseRetryDuration":           "The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.",
		"elementsUseViewTransitions": "Should elements be patched using the ViewTransition API?",
		"patchSignalsOnlyIfMissing":  "Should a given set of signals patch if they are missing?",
	}
	return descriptions[name]
}

func fetchFromGitHub(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch %s: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch %s: status %d", url, resp.StatusCode)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response from %s: %w", url, err)
	}

	return data, nil
}

func main() {
	// Get branch from environment or use default
	branch := os.Getenv("DATASTAR_BRANCH")
	if branch == "" {
		branch = "repo-per-sdk"
	}

	// Fetch config from GitHub
	configURL := fmt.Sprintf("https://raw.githubusercontent.com/starfederation/datastar/%s/sdk/datastar-sdk-config-v1.json", branch)
	configData, err := fetchFromGitHub(configURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching config: %v\n", err)
		os.Exit(1)
	}

	// Fetch schema from GitHub
	schemaURL := fmt.Sprintf("https://raw.githubusercontent.com/starfederation/datastar/%s/sdk/datastar-sdk-config-v1.schema.json", branch)
	schemaData, err := fetchFromGitHub(schemaURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching schema: %v\n", err)
		os.Exit(1)
	}

	// Parse schema
	var schemaJSON interface{}
	if err := json.Unmarshal(schemaData, &schemaJSON); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing schema: %v\n", err)
		os.Exit(1)
	}
	
	compiler := jsonschema.NewCompiler()
	if err := compiler.AddResource(schemaURL, schemaJSON); err != nil {
		fmt.Fprintf(os.Stderr, "Error adding schema resource: %v\n", err)
		os.Exit(1)
	}
	
	schema, err := compiler.Compile(schemaURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error compiling schema: %v\n", err)
		os.Exit(1)
	}

	// Parse JSON
	var config map[string]interface{}
	if err := json.Unmarshal(configData, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing config: %v\n", err)
		os.Exit(1)
	}


	// Validate against schema
	if err := schema.Validate(config); err != nil {
		// Check if only missing version
		errStr := err.Error()
		if !strings.Contains(errStr, "missing property 'version'") {
			fmt.Fprintf(os.Stderr, "Schema validation failed: %v\n", err)
			os.Exit(1)
		}
		// If only version is missing, continue (known issue with schema/config mismatch)
	}
	
	// Add computed fields
	config["doNotEdit"] = "This is auto-generated by Datastar. DO NOT EDIT."

	// Add helper functions to template
	funcMap := template.FuncMap{
		"toPascalCase": toPascalCase,
		"getDefaultDescription": getDefaultDescription,
	}

	// Generate output
	tmpl := template.Must(template.New("consts").Funcs(funcMap).Parse(goConstsTemplate))
	
	outputPath := "../../datastar/consts.go"
	outputFile, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, config); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", outputPath)
}

// Go template that works directly with JSON structure
const goConstsTemplate = `// {{.doNotEdit}}

package datastar

import "time"

const (
	DatastarKey = "{{.datastarKey}}"

{{- range $name, $value := .defaults.durations}}
	// {{getDefaultDescription $name}}
	Default{{toPascalCase $name}} = {{$value}} * time.Millisecond
{{- end}}

{{- range .datalineLiterals}}
	{{toPascalCase .}}DatalineLiteral = "{{.}} "
{{- end}}
)

var (
{{- range $name, $value := .defaults.booleans}}
	// {{getDefaultDescription $name}}
	Default{{toPascalCase $name}} = {{$value}}
{{- end}}
)

{{range $enumName, $enum := .enums}}
// {{$enum.description}}
type {{$enumName}} string

const (
{{- if $enum.default}}
	// Default value for {{$enumName}}
	{{- range $enum.values}}
	{{- if eq .value $enum.default}}
	// {{.description}}
	Default{{$enumName}} = {{$enumName}}{{toPascalCase .value}}
	{{- end}}
	{{- end}}
{{end}}
{{- range $enum.values}}
	// {{.description}}
	{{- if .name}}
	{{$enumName}}{{.name}} {{$enumName}} = "{{.value}}"
	{{- else}}
	{{$enumName}}{{toPascalCase .value}} {{$enumName}} = "{{.value}}"
	{{- end}}
{{- end}}
)
{{end}}
`